#!/usr/bin/python

import roslib
roslib.load_manifest('mdr_lab_demo')

import rospy
import smach
import smach_ros

from mdr_lab_demo.lab_demo_states import *

from mdr_common_states.common_state_machines import *
from mdr_common_states.common_states import *
	
# main
def main():
	rospy.init_node('lab_demo')

	# Create a SMACH state machine
	sm = smach.StateMachine(outcomes=['overall_success', 'overall_failed'])
	
	
	names_to_understand = rospy.get_param('/script_server/speech_names')
	speech_grammar_file = rospy.get_param('/SpeechGrammarFile')
	
	# TODO: Adapt for competiton######################################### 
	sm.userdata.pose = "living_room" 
	sm.userdata.robot_state = Robot_state()
	sm.userdata.robot_state.actual_location = sm.userdata.pose
	
	sm.userdata.person_pose = ""
	sm.userdata.commands_to_wait_for = ["stop_follow_me", "stop_guiding"]
	sm.userdata.keyword_list = []
	sm.userdata.confidence_list = []
	sm.userdata.understood_command = ""
	sm.userdata.action_list = []
	sm.userdata.action_object = ""
	sm.userdata.clean_object = "sponge"
	sm.userdata.person_name = ""
	sm.userdata.grasp_pose = ""
	sm.userdata.gpsr_prefix = GPSR_PREFIX
	sm.userdata.getit_prefix = 'gpsr_'
	sm.userdata.recognized_person_name = ""
	
	sm.userdata.search_persons_room_suffix = '' 
	sm.userdata.announce_phrase = ""
	sm.userdata.already_executed_actions = []
	sm.userdata.search_person_pose = ""
	sm.userdata.robot_state = Robot_state()
	sm.userdata.current_action = ""
	
	sm.userdata.underscore = "_"
	sm.userdata.space = " "
	sm.userdata.empty_string = ""
	
	sm.userdata.bottle_state = 0
	sm.userdata.force_x_with_bottle = 0
	sm.userdata.room_poses = []
	
	#COMPETITION TODO:
	#Adapt  speech locations + grammar
		#define 'speech_location' for each defined location
		#define gpsr_'speech_location'+i for each search pose -> can the gogetit be reused?
		#define gpsr_'speech_location_find_person'+i for each search pose -> can the who_is_who be reused?
		
	#Adapt  speech objects + grammar
	#Adapt  speech names + grammar
	# define pose initially (~line 252) with the room that is started
	
	# Open the container
	with sm:
		
		# init base
		mystate = smach.StateMachine.add('init_base', init_base(), transitions={'success':'init_torso', 'failed':'overall_failed'})

		# init torso
		smach.StateMachine.add('init_torso', init_torso(), transitions={'success':'init_manipulator', 'failed':'overall_failed'})
	
		# init manipulator
		smach.StateMachine.add('init_manipulator', init_manipulator(), transitions={'success':'load_faces', 'failed':'overall_failed'})
	
		# load the faces for the face recognition
		smach.StateMachine.add('load_faces', load_faces(),  transitions={'success':'general_checklist','failed':'overall_failed'})
		
		# checklist
		smach.StateMachine.add('general_checklist', general_checklist(),  transitions={'success':'announce_ready'})
		
		# announce ready
		smach.StateMachine.add('announce_ready', announce_ready(), transitions={'success':'wait_for_start','failed':'overall_failed'})

		# wait for start
		smach.StateMachine.add('wait_for_start', wait_for_start(), transitions={'success':'approach_start', 'pending':'wait_for_start'})
		
		# enter arena output_keys=['pose']
		smach.StateMachine.add('enter_arena', enter_arena(), transitions={'success':'approach_start', 'failed':'overall_failed'})
		
		smach.StateMachine.add('approach_start', approach_pose("living_room"), transitions={'success':'init_speech', 'failed':'init_speech'})
		

		
		############################# Understanding phase ##############################
		# init speech
		smach.StateMachine.add('init_speech', init_speech(speech_grammar_file), transitions={'success':'move_actuators_to_home_poses', 'failed':'overall_failed'})
		
		smach.StateMachine.add('move_actuators_to_home_poses', move_actuators_to_home_poses(), transitions={'success':'request_commands'})
		
		# announce ready
		smach.StateMachine.add('request_commands',say_state("please state your command"), 
											transitions={'success':'wait_for_command'})	
		
		# wait for complex command
		smach.StateMachine.add('wait_for_command', wait_for_arbitrary_phrase(), 
							transitions={'success':'decompose_speech_phrase', 'not_understood':'wait_for_command'},
							remapping={'keyword_list_out':'keyword_list',
										'confidence_list_out':'confidence_list'})
	
		# decompose to a set of 3 actions / commands
		smach.StateMachine.add('decompose_speech_phrase', decompose_speech_phrase(), 
							transitions={'success':'acknowledge_phrase', 'not_understood':'please_repeat'},
							remapping={'keyword_list_in':'keyword_list', 
										'confidence_list_in':'confidence_list',
										'understood_phrase_out':'understood_command',
										'previous_understood_action_list_in':'action_list',
										'action_list_out':'action_list',
										'current_room_in':'pose'})
		
		# ask for repition
		smach.StateMachine.add('please_repeat', say_state("I didn't understand you"), 
									transitions={'success':'init_speech'})	
		
		#switch grammar to yes / no
		#smach.StateMachine.add('load_ack_grammar', init_speech("acknowledge_top_level.xml"), transitions={'success':'acknowledge_phrase', 'failed':'approach_start'})
		
		#acknowledge the command
		smach.StateMachine.add('acknowledge_phrase', acknowledge_command_with_loading_grammar(), 
						transitions={'yes':'execute_commands', 'no':'init_speech'},
						remapping={'understood_command':'understood_command'})
		
		
		##################### execution phase ######################
		smach.StateMachine.add('execute_commands', execute_commands(), 
						transitions={'success': 'approach_start',
									'failed' : 'approach_start',
									PENDING : 'execute_commands',
									INTRODUCE : 'introduce',
									LEARN_PERSON:'learn_person_sub',
									FIND_PERSON:'get_room_poses_for_person_finding',
									IDENTIFY_PERSON:'wait_for_person_to_recognize',
									FOLLOW : 'change_grammar_follow_me',
									GUIDE : 'change_grammar_guiding',
									MOVE_TO:'move_to_pose',
									DETECT_OBJECT:'search_object_sub',
									GRASP:'identify_object',
									CLEAN_TABLE:'identify_object_for_cleaning',
									POINT_TO_OBJECT:'identify_object_for_pointing',
									WEIGHT:'put_bottle_in_hand',
									CARRY_BOX: 'carry_beer_box',
									RELEASE:'release_object',
									HANDOVER:'deliver_object',
									CATEGORIZE_OBJECTS:'categorize_objects',
									EXIT:'leave_arena'},
						remapping={'actions_to_execute_in':'action_list', 
									'actions_left_out':'action_list',
									'already_executed_actions_in':'already_executed_actions',
									'already_executed_actions_out':'already_executed_actions',
									'robot_state_in' : 'robot_state',
									'pose_out' : 'pose',
									'object_out': 'action_object',
									'current_action_out':'current_action'})
		
		smach.StateMachine.add('introduce', introduce(), 
									transitions={'success':'execute_commands'})
		
		#learn a person						
			#load the sub-statemachine
		sub_sm_learn_person = sm_learn_person(names_to_understand, "gpsr1.xml")		
		smach.StateMachine.add('learn_person_sub', sub_sm_learn_person, 
								transitions={'success_learned_person':'execute_commands', 'overall_failed':'execute_commands'},
								remapping={'sm_learn_person_person_name_out':'person_name'})
		
		#find person
		smach.StateMachine.add('get_room_poses_for_person_finding', get_room_poses(), 
								transitions={'success':'find_person_sub'},
								remapping={'room_name':'pose'}) 	
		#load sub statemachine
		sub_sm_search_persons = sm_search_a_person()		
		smach.StateMachine.add('find_person_sub', sub_sm_search_persons, 
								transitions={'success_search_person':'recognize_found_person', 'overall_failed':'find_person_sub'})
		
		smach.StateMachine.add('recognize_found_person', recognize_person(), transitions={'success':'execute_commands', 'failed':'execute_commands'})	
		
		
		#identify person		
		smach.StateMachine.add('wait_for_person_to_recognize', is_person_in_front(), 
									transitions={'failed':'recognize_person', 'success':'recognize_person'})
		
		smach.StateMachine.add('recognize_person', recognize_person(), 
								transitions={'success':'execute_commands',
											'failed':'execute_commands'})									
		
		# follow person
			# change grammar for follow me
		smach.StateMachine.add('change_grammar_follow_me', init_speech("follow_me.xml"), transitions={'success':'init_followme', 'failed':'execute_commands'})
		
			# init the follow me behavior	
		smach.StateMachine.add('init_followme', init_followme(), transitions={'success':'announce_follow','failed':'execute_commands'})
			#say how to stop
		smach.StateMachine.add('announce_follow', say_state("Please tell me to stop by saying stop follow me"), 
						transitions={'success':'wait_for_stop_command'})	

			# wait for the stop command	
		smach.StateMachine.add('wait_for_stop_command', wait_for_command(), 
								transitions={'success':'confirm_stop_followme'})
		
		smach.StateMachine.add('confirm_stop_followme', acknowledge_command(), 
					transitions={'yes':'stop_following', 'no':'wait_for_stop_command'})
		
		smach.StateMachine.add('stop_following', stop_following(), 
					transitions={'success':'execute_commands', 'failed':'execute_commands'})
		
		
		# guiding behavior
			# change grammar for guiding
		smach.StateMachine.add('change_grammar_guiding', init_speech("guide.xml"), transitions={'success':'init_guiding', 'failed':'execute_commands'})
		
			# init the guiding behavior	
		smach.StateMachine.add('init_guiding', init_guiding(), transitions={'success':'announce_guiding','failed':'execute_commands'})
			#say how to stop
		smach.StateMachine.add('announce_guiding', say_state("Please tell me to stop by saying stop guiding me"), 
						transitions={'success':'wait_for_guiding_stop_command'})	

			# wait for the stop command	
		smach.StateMachine.add('wait_for_guiding_stop_command', wait_for_command(), 
								transitions={'success':'confirm_stop_guiding'})
		
		smach.StateMachine.add('confirm_stop_guiding', acknowledge_command(), 
					transitions={'yes':'stop_guiding', 'no':'wait_for_guiding_stop_command'})
		
		smach.StateMachine.add('stop_guiding', stop_guiding(), 
					transitions={'success':'execute_commands', 'failed':'execute_commands'})
		
		#carry box sub state machine
		smach.StateMachine.add('carry_beer_box', carry_beer_box(), 
					transitions={'success':'execute_commands', 'failed':'execute_commands'})
		
		#move_to
		smach.StateMachine.add('move_to_pose', approach_pose(), transitions={'success':'update_robot_state', 'failed':'execute_commands'},
											remapping={'pose':'pose'})

		#detect object / find object
			#load the sub-statemachine
		sub_sm_search_object = sm_search_object()		
		smach.StateMachine.add('search_object_sub', sub_sm_search_object, 
								transitions={'success_search_object':'say_found_object', 'overall_failed':'restore_robot_state_after_find_object'}, #redo search otherwise its lost anyway
								remapping={'sm_search_object_grasp_pose_out':'grasp_pose',
											'sm_search_object_base_pose_out':'pose',
											'sm_search_object_room_to_search_in':'pose',
											'sm_search_object_room_prefix_in': 'getit_prefix',
											'sm_search_object_room_suffix_in': 'empty_string',
											'sm_search_object_object_to_search_in':'action_object'})
		
		smach.StateMachine.add('restore_robot_state_after_find_object', get_robot_state(), 
											transitions={'success':'execute_commands'},
											remapping={'actual_location_out':'pose',
														'robot_state_in':'robot_state'})	
				
		smach.StateMachine.add('say_found_object',say_state_dynamic("I found the ", ""), 
											transitions={'success':'update_robot_state'},
											remapping={'phrase_in':'action_object'})	
		
		#point to object
		smach.StateMachine.add('identify_object_for_pointing', find_object_moped(),
								transitions={'success':'point_to_object', # point to if found
											'failed':'execute_commands'}, # otherwise search again
								remapping={'grasp_position': 'grasp_pose', 'object_name': 'action_object'})	
			# point
		smach.StateMachine.add('point_to_object', point_to_object(),
								transitions={'success':'execute_commands',
											'failed':'execute_commands'},
								remapping={'grasp_position':'grasp_pose'})		
		
		#clean table
			# Detect Item if inital grasp didn't succeed	
		smach.StateMachine.add('identify_object_for_cleaning', find_object_moped(),
								transitions={'success':'clean_table', # grasp if found
											'failed':'execute_commands'}, # otherwise search again
								remapping={'grasp_position': 'grasp_pose', 'object_name': 'clean_object'})	
			# clean the table
		smach.StateMachine.add('clean_table', clean_table(),
								transitions={'success':'execute_commands', # ALTERNATIVE move_back_to_start 
											'failed':'execute_commands'},
								remapping={'grasp_position':'grasp_pose'})	
		
		#grasp
			# Detect Item if inital grasp didn't succeed	
		smach.StateMachine.add('identify_object', find_object_moped(),
								transitions={'success':'grasp_object', # grasp if found
											'failed':'execute_commands'}, # otherwise search again
								remapping={'grasp_position': 'grasp_pose', 'object_name': 'action_object'})	
			# grasp Item
		smach.StateMachine.add('grasp_object', grasp_object(),
								transitions={'success':'update_robot_state', # ALTERNATIVE move_back_to_start 
											'failed':'execute_commands',
											'retry':'identify_object'},
								remapping={'grasp_position':'grasp_pose'})	

		#release object
		smach.StateMachine.add('release_object', release_object(), transitions={'success':'update_robot_state', 'failed':'update_robot_state'})	


		#Weight Bottle
		smach.StateMachine.add('put_bottle_in_hand', put_object_in_hand(), transitions={'success':'weight_bottle', 'failed':'execute_commands'})	

		smach.StateMachine.add('weight_bottle', weight_bottle(), transitions={'success':'release_object', 'failed':'update_robot_state'}, 
																remapping={'bottle_state':'bottle_state','force_x_with_bottle':'force_x_with_bottle'})	
		
		
		# move back and deliver object after cmmands execution						
	#	smach.StateMachine.add('move_back_to_start', approach_pose("living_room"), transitions={'success':'deliver_object', 'failed':'deliver_object'})
		
		smach.StateMachine.add('deliver_object', hand_over_object(), transitions={'success':'update_robot_state', 'failed':'update_robot_state'})
		
		smach.StateMachine.add('categorize_objects', categorize_objects(), transitions={'success':'update_robot_state', 'failed':'update_robot_state'})			
		
		
		
		# after every movement, grasp, object_detection, the robot state is updated
		smach.StateMachine.add('update_robot_state', update_robot_state(), transitions={'success':'execute_commands'},
									remapping={'robot_position_in':'pose', 
										'object_name_in':'action_object',										
										'grasp_pose_in':'grasp_pose',
										'executed_action_in':'current_action',
										'robot_state_in':'robot_state',
										'robot_state_out':'robot_state'})
		
		#exit
		smach.StateMachine.add('leave_arena', move_to_exit(), transitions={'success':'overall_success'})

									
	# Create and start the introspection server
	sis = smach_ros.IntrospectionServer('server_name', sm, '/SM_ROOT')
	sis.start()

	# Execute the state machine
	#rospy.sleep(5)
	outcome = sm.execute()
	
	# Wait for ctrl-c to stop the application
	rospy.spin()
	sis.stop()

if __name__ == '__main__':
	main()

